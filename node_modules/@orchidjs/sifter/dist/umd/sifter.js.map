{"version":3,"file":"sifter.js","sources":["../../node_modules/@orchidjs/unicode-variants/dist/esm/regex.js","../../node_modules/@orchidjs/unicode-variants/dist/esm/strings.js","../../node_modules/@orchidjs/unicode-variants/dist/esm/index.js","../../lib/utils.ts","../../lib/sifter.ts"],"sourcesContent":["/**\n * Convert array of strings to a regular expression\n *\tex ['ab','a'] => (?:ab|a)\n * \tex ['a','b'] => [ab]\n */\nexport const arrayToPattern = (chars) => {\n    chars = chars.filter(Boolean);\n    if (chars.length < 2) {\n        return chars[0] || '';\n    }\n    return (maxValueLength(chars) == 1) ? '[' + chars.join('') + ']' : '(?:' + chars.join('|') + ')';\n};\nexport const sequencePattern = (array) => {\n    if (!hasDuplicates(array)) {\n        return array.join('');\n    }\n    let pattern = '';\n    let prev_char_count = 0;\n    const prev_pattern = () => {\n        if (prev_char_count > 1) {\n            pattern += '{' + prev_char_count + '}';\n        }\n    };\n    array.forEach((char, i) => {\n        if (char === array[i - 1]) {\n            prev_char_count++;\n            return;\n        }\n        prev_pattern();\n        pattern += char;\n        prev_char_count = 1;\n    });\n    prev_pattern();\n    return pattern;\n};\n/**\n * Convert array of strings to a regular expression\n *\tex ['ab','a'] => (?:ab|a)\n * \tex ['a','b'] => [ab]\n */\nexport const setToPattern = (chars) => {\n    let array = Array.from(chars);\n    return arrayToPattern(array);\n};\n/**\n * https://stackoverflow.com/questions/7376598/in-javascript-how-do-i-check-if-an-array-has-duplicate-values\n */\nexport const hasDuplicates = (array) => {\n    return (new Set(array)).size !== array.length;\n};\n/**\n * https://stackoverflow.com/questions/63006601/why-does-u-throw-an-invalid-escape-error\n */\nexport const escape_regex = (str) => {\n    return (str + '').replace(/([\\$\\(\\)\\*\\+\\.\\?\\[\\]\\^\\{\\|\\}\\\\])/gu, '\\\\$1');\n};\n/**\n * Return the max length of array values\n */\nexport const maxValueLength = (array) => {\n    return array.reduce((longest, value) => Math.max(longest, unicodeLength(value)), 0);\n};\nexport const unicodeLength = (str) => {\n    return Array.from(str).length;\n};\n//# sourceMappingURL=regex.js.map","/**\n * Get all possible combinations of substrings that add up to the given string\n * https://stackoverflow.com/questions/30169587/find-all-the-combination-of-substrings-that-add-up-to-the-given-string\n */\nexport const allSubstrings = (input) => {\n    if (input.length === 1)\n        return [[input]];\n    let result = [];\n    const start = input.substring(1);\n    const suba = allSubstrings(start);\n    suba.forEach(function (subresult) {\n        let tmp = subresult.slice(0);\n        tmp[0] = input.charAt(0) + tmp[0];\n        result.push(tmp);\n        tmp = subresult.slice(0);\n        tmp.unshift(input.charAt(0));\n        result.push(tmp);\n    });\n    return result;\n};\n//# sourceMappingURL=strings.js.map","import { setToPattern, arrayToPattern, escape_regex, sequencePattern } from \"./regex.js\";\nimport { allSubstrings } from \"./strings.js\";\nexport const code_points = [[0, 65535]];\nconst accent_pat = '[\\u0300-\\u036F\\u{b7}\\u{2be}\\u{2bc}]';\nexport let unicode_map;\nlet multi_char_reg;\nconst max_char_length = 3;\nconst latin_convert = {};\nconst latin_condensed = {\n    '/': '⁄∕',\n    '0': '߀',\n    \"a\": \"ⱥɐɑ\",\n    \"aa\": \"ꜳ\",\n    \"ae\": \"æǽǣ\",\n    \"ao\": \"ꜵ\",\n    \"au\": \"ꜷ\",\n    \"av\": \"ꜹꜻ\",\n    \"ay\": \"ꜽ\",\n    \"b\": \"ƀɓƃ\",\n    \"c\": \"ꜿƈȼↄ\",\n    \"d\": \"đɗɖᴅƌꮷԁɦ\",\n    \"e\": \"ɛǝᴇɇ\",\n    \"f\": \"ꝼƒ\",\n    \"g\": \"ǥɠꞡᵹꝿɢ\",\n    \"h\": \"ħⱨⱶɥ\",\n    \"i\": \"ɨı\",\n    \"j\": \"ɉȷ\",\n    \"k\": \"ƙⱪꝁꝃꝅꞣ\",\n    \"l\": \"łƚɫⱡꝉꝇꞁɭ\",\n    \"m\": \"ɱɯϻ\",\n    \"n\": \"ꞥƞɲꞑᴎлԉ\",\n    \"o\": \"øǿɔɵꝋꝍᴑ\",\n    \"oe\": \"œ\",\n    \"oi\": \"ƣ\",\n    \"oo\": \"ꝏ\",\n    \"ou\": \"ȣ\",\n    \"p\": \"ƥᵽꝑꝓꝕρ\",\n    \"q\": \"ꝗꝙɋ\",\n    \"r\": \"ɍɽꝛꞧꞃ\",\n    \"s\": \"ßȿꞩꞅʂ\",\n    \"t\": \"ŧƭʈⱦꞇ\",\n    \"th\": \"þ\",\n    \"tz\": \"ꜩ\",\n    \"u\": \"ʉ\",\n    \"v\": \"ʋꝟʌ\",\n    \"vy\": \"ꝡ\",\n    \"w\": \"ⱳ\",\n    \"y\": \"ƴɏỿ\",\n    \"z\": \"ƶȥɀⱬꝣ\",\n    \"hv\": \"ƕ\"\n};\nfor (let latin in latin_condensed) {\n    let unicode = latin_condensed[latin] || '';\n    for (let i = 0; i < unicode.length; i++) {\n        let char = unicode.substring(i, i + 1);\n        latin_convert[char] = latin;\n    }\n}\nconst convert_pat = new RegExp(Object.keys(latin_convert).join('|') + '|' + accent_pat, 'gu');\n/**\n * Initialize the unicode_map from the give code point ranges\n */\nexport const initialize = (_code_points) => {\n    if (unicode_map !== undefined)\n        return;\n    unicode_map = generateMap(_code_points || code_points);\n};\n/**\n * Helper method for normalize a string\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize\n */\nexport const normalize = (str, form = 'NFKD') => str.normalize(form);\n/**\n * Remove accents without reordering string\n * calling str.normalize('NFKD') on \\u{594}\\u{595}\\u{596} becomes \\u{596}\\u{594}\\u{595}\n * via https://github.com/krisk/Fuse/issues/133#issuecomment-318692703\n */\nexport const asciifold = (str) => {\n    return Array.from(str).reduce(\n    /**\n     * @param {string} result\n     * @param {string} char\n     */\n    (result, char) => {\n        return result + _asciifold(char);\n    }, '');\n};\nexport const _asciifold = (str) => {\n    str = normalize(str)\n        .toLowerCase()\n        .replace(convert_pat, (/** @type {string} */ char) => {\n        return latin_convert[char] || '';\n    });\n    //return str;\n    return normalize(str, 'NFC');\n};\n/**\n * Generate a list of unicode variants from the list of code points\n */\nexport function* generator(code_points) {\n    for (const [code_point_min, code_point_max] of code_points) {\n        for (let i = code_point_min; i <= code_point_max; i++) {\n            let composed = String.fromCharCode(i);\n            let folded = asciifold(composed);\n            if (folded == composed.toLowerCase()) {\n                continue;\n            }\n            // skip when folded is a string longer than 3 characters long\n            // bc the resulting regex patterns will be long\n            // eg:\n            // folded صلى الله عليه وسلم length 18 code point 65018\n            // folded جل جلاله length 8 code point 65019\n            if (folded.length > max_char_length) {\n                continue;\n            }\n            if (folded.length == 0) {\n                continue;\n            }\n            yield { folded: folded, composed: composed, code_point: i };\n        }\n    }\n}\n/**\n * Generate a unicode map from the list of code points\n */\nexport const generateSets = (code_points) => {\n    const unicode_sets = {};\n    const addMatching = (folded, to_add) => {\n        /** @type {Set<string>} */\n        const folded_set = unicode_sets[folded] || new Set();\n        const patt = new RegExp('^' + setToPattern(folded_set) + '$', 'iu');\n        if (to_add.match(patt)) {\n            return;\n        }\n        folded_set.add(escape_regex(to_add));\n        unicode_sets[folded] = folded_set;\n    };\n    for (let value of generator(code_points)) {\n        addMatching(value.folded, value.folded);\n        addMatching(value.folded, value.composed);\n    }\n    return unicode_sets;\n};\n/**\n * Generate a unicode map from the list of code points\n * ae => (?:(?:ae|Æ|Ǽ|Ǣ)|(?:A|Ⓐ|Ａ...)(?:E|ɛ|Ⓔ...))\n */\nexport const generateMap = (code_points) => {\n    const unicode_sets = generateSets(code_points);\n    const unicode_map = {};\n    let multi_char = [];\n    for (let folded in unicode_sets) {\n        let set = unicode_sets[folded];\n        if (set) {\n            unicode_map[folded] = setToPattern(set);\n        }\n        if (folded.length > 1) {\n            multi_char.push(escape_regex(folded));\n        }\n    }\n    multi_char.sort((a, b) => b.length - a.length);\n    const multi_char_patt = arrayToPattern(multi_char);\n    multi_char_reg = new RegExp('^' + multi_char_patt, 'u');\n    return unicode_map;\n};\n/**\n * Map each element of an array from its folded value to all possible unicode matches\n */\nexport const mapSequence = (strings, min_replacement = 1) => {\n    let chars_replaced = 0;\n    strings = strings.map((str) => {\n        if (unicode_map[str]) {\n            chars_replaced += str.length;\n        }\n        return unicode_map[str] || str;\n    });\n    if (chars_replaced >= min_replacement) {\n        return sequencePattern(strings);\n    }\n    return '';\n};\n/**\n * Convert a short string and split it into all possible patterns\n * Keep a pattern only if min_replacement is met\n *\n * 'abc'\n * \t\t=> [['abc'],['ab','c'],['a','bc'],['a','b','c']]\n *\t\t=> ['abc-pattern','ab-c-pattern'...]\n */\nexport const substringsToPattern = (str, min_replacement = 1) => {\n    min_replacement = Math.max(min_replacement, str.length - 1);\n    return arrayToPattern(allSubstrings(str).map((sub_pat) => {\n        return mapSequence(sub_pat, min_replacement);\n    }));\n};\n/**\n * Convert an array of sequences into a pattern\n * [{start:0,end:3,length:3,substr:'iii'}...] => (?:iii...)\n */\nconst sequencesToPattern = (sequences, all = true) => {\n    let min_replacement = sequences.length > 1 ? 1 : 0;\n    return arrayToPattern(sequences.map((sequence) => {\n        let seq = [];\n        const len = all ? sequence.length() : sequence.length() - 1;\n        for (let j = 0; j < len; j++) {\n            seq.push(substringsToPattern(sequence.substrs[j] || '', min_replacement));\n        }\n        return sequencePattern(seq);\n    }));\n};\n/**\n * Return true if the sequence is already in the sequences\n */\nconst inSequences = (needle_seq, sequences) => {\n    for (const seq of sequences) {\n        if (seq.start != needle_seq.start || seq.end != needle_seq.end) {\n            continue;\n        }\n        if (seq.substrs.join('') !== needle_seq.substrs.join('')) {\n            continue;\n        }\n        let needle_parts = needle_seq.parts;\n        const filter = (part) => {\n            for (const needle_part of needle_parts) {\n                if (needle_part.start === part.start && needle_part.substr === part.substr) {\n                    return false;\n                }\n                if (part.length == 1 || needle_part.length == 1) {\n                    continue;\n                }\n                // check for overlapping parts\n                // a = ['::=','==']\n                // b = ['::','===']\n                // a = ['r','sm']\n                // b = ['rs','m']\n                if (part.start < needle_part.start && part.end > needle_part.start) {\n                    return true;\n                }\n                if (needle_part.start < part.start && needle_part.end > part.start) {\n                    return true;\n                }\n            }\n            return false;\n        };\n        let filtered = seq.parts.filter(filter);\n        if (filtered.length > 0) {\n            continue;\n        }\n        return true;\n    }\n    return false;\n};\nclass Sequence {\n    parts;\n    substrs;\n    start;\n    end;\n    constructor() {\n        this.parts = [];\n        this.substrs = [];\n        this.start = 0;\n        this.end = 0;\n    }\n    add(part) {\n        if (part) {\n            this.parts.push(part);\n            this.substrs.push(part.substr);\n            this.start = Math.min(part.start, this.start);\n            this.end = Math.max(part.end, this.end);\n        }\n    }\n    last() {\n        return this.parts[this.parts.length - 1];\n    }\n    length() {\n        return this.parts.length;\n    }\n    clone(position, last_piece) {\n        let clone = new Sequence();\n        let parts = JSON.parse(JSON.stringify(this.parts));\n        let last_part = parts.pop();\n        for (const part of parts) {\n            clone.add(part);\n        }\n        let last_substr = last_piece.substr.substring(0, position - last_part.start);\n        let clone_last_len = last_substr.length;\n        clone.add({ start: last_part.start, end: last_part.start + clone_last_len, length: clone_last_len, substr: last_substr });\n        return clone;\n    }\n}\n/**\n * Expand a regular expression pattern to include unicode variants\n * \teg /a/ becomes /aⓐａẚàáâầấẫẩãāăằắẵẳȧǡäǟảåǻǎȁȃạậặḁąⱥɐɑAⒶＡÀÁÂẦẤẪẨÃĀĂẰẮẴẲȦǠÄǞẢÅǺǍȀȂẠẬẶḀĄȺⱯ/\n *\n * Issue:\n *  ﺊﺋ [ 'ﺊ = \\\\u{fe8a}', 'ﺋ = \\\\u{fe8b}' ]\n *\tbecomes:\tئئ [ 'ي = \\\\u{64a}', 'ٔ = \\\\u{654}', 'ي = \\\\u{64a}', 'ٔ = \\\\u{654}' ]\n *\n *\tİĲ = IIJ = ⅡJ\n *\n * \t1/2/4\n */\nexport const getPattern = (str) => {\n    initialize();\n    str = asciifold(str);\n    let pattern = '';\n    let sequences = [new Sequence()];\n    for (let i = 0; i < str.length; i++) {\n        let substr = str.substring(i);\n        let match = substr.match(multi_char_reg);\n        const char = str.substring(i, i + 1);\n        const match_str = match ? match[0] : null;\n        // loop through sequences\n        // add either the char or multi_match\n        let overlapping = [];\n        let added_types = new Set();\n        for (const sequence of sequences) {\n            const last_piece = sequence.last();\n            if (!last_piece || last_piece.length == 1 || last_piece.end <= i) {\n                // if we have a multi match\n                if (match_str) {\n                    const len = match_str.length;\n                    sequence.add({ start: i, end: i + len, length: len, substr: match_str });\n                    added_types.add('1');\n                }\n                else {\n                    sequence.add({ start: i, end: i + 1, length: 1, substr: char });\n                    added_types.add('2');\n                }\n            }\n            else if (match_str) {\n                let clone = sequence.clone(i, last_piece);\n                const len = match_str.length;\n                clone.add({ start: i, end: i + len, length: len, substr: match_str });\n                overlapping.push(clone);\n            }\n            else {\n                // don't add char\n                // adding would create invalid patterns: 234 => [2,34,4]\n                added_types.add('3');\n            }\n        }\n        // if we have overlapping\n        if (overlapping.length > 0) {\n            // ['ii','iii'] before ['i','i','iii']\n            overlapping = overlapping.sort((a, b) => {\n                return a.length() - b.length();\n            });\n            for (let clone of overlapping) {\n                // don't add if we already have an equivalent sequence\n                if (inSequences(clone, sequences)) {\n                    continue;\n                }\n                sequences.push(clone);\n            }\n            continue;\n        }\n        // if we haven't done anything unique\n        // clean up the patterns\n        // helps keep patterns smaller\n        // if str = 'r₨㎧aarss', pattern will be 446 instead of 655\n        if (i > 0 && added_types.size == 1 && !added_types.has('3')) {\n            pattern += sequencesToPattern(sequences, false);\n            let new_seq = new Sequence();\n            const old_seq = sequences[0];\n            if (old_seq) {\n                new_seq.add(old_seq.last());\n            }\n            sequences = [new_seq];\n        }\n    }\n    pattern += sequencesToPattern(sequences, true);\n    return pattern;\n};\nexport { escape_regex };\n//# sourceMappingURL=index.js.map","\nimport { asciifold } from '@orchidjs/unicode-variants';\nimport * as T from './types.ts';\n\n\n/**\n * A property getter resolving dot-notation\n * @param  {Object}  obj     The root object to fetch property on\n * @param  {String}  name    The optionally dotted property name to fetch\n * @return {Object}          The resolved property value\n */\nexport const getAttr = (obj:{[key:string]:any}, name:string ) => {\n    if (!obj ) return;\n    return obj[name];\n};\n\n/**\n * A property getter resolving dot-notation\n * @param  {Object}  obj     The root object to fetch property on\n * @param  {String}  name    The optionally dotted property name to fetch\n * @return {Object}          The resolved property value\n */\nexport const getAttrNesting = (obj:{[key:string]:any}, name:string ) => {\n    if (!obj ) return;\n    var part, names = name.split(\".\");\n\twhile( (part = names.shift()) && (obj = obj[part]));\n    return obj;\n};\n\n/**\n * Calculates how close of a match the\n * given value is against a search token.\n *\n */\nexport const scoreValue = (value:string, token:T.Token, weight:number ):number => {\n\tvar score, pos;\n\n\tif (!value) return 0;\n\n\tvalue = value + '';\n\tif( token.regex == null ) return 0;\n\tpos = value.search(token.regex);\n\tif (pos === -1) return 0;\n\n\tscore = token.string.length / value.length;\n\tif (pos === 0) score += 0.5;\n\n\treturn score * weight;\n};\n\n\n/**\n * Cast object property to an array if it exists and has a value\n *\n */\nexport const propToArray = (obj:{[key:string]:any}, key:string) => {\n\tvar value = obj[key];\n\n\tif( typeof value == 'function' ) return value;\n\n\tif( value && !Array.isArray(value) ){\n\t\tobj[key] = [value];\n\t}\n}\n\n\n/**\n * Iterates over arrays and hashes.\n *\n * ```\n * iterate(this.items, function(item, id) {\n *    // invoked for each item\n * });\n * ```\n *\n */\nexport const iterate = (object:[]|{[key:string]:any}, callback:(value:any,key:any)=>any) => {\n\n\tif ( Array.isArray(object)) {\n\t\tobject.forEach(callback);\n\n\t}else{\n\n\t\tfor (var key in object) {\n\t\t\tif (object.hasOwnProperty(key)) {\n\t\t\t\tcallback(object[key], key);\n\t\t\t}\n\t\t}\n\t}\n};\n\n\n\nexport const cmp = (a:number|string, b:number|string) => {\n\tif (typeof a === 'number' && typeof b === 'number') {\n\t\treturn a > b ? 1 : (a < b ? -1 : 0);\n\t}\n\ta = asciifold(a + '').toLowerCase();\n\tb = asciifold(b + '').toLowerCase();\n\tif (a > b) return 1;\n\tif (b > a) return -1;\n\treturn 0;\n};\n","/**\n * sifter.js\n * Copyright (c) 2013–2020 Brian Reavis & contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this\n * file except in compliance with the License. You may obtain a copy of the License at:\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n * ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n *\n * @author Brian Reavis <brian@thirdroute.com>\n */\n\nimport { scoreValue, getAttr, getAttrNesting, propToArray, iterate, cmp } from './utils.ts';\nimport { getPattern, escape_regex } from '@orchidjs/unicode-variants';\nimport * as T from './types.ts';\n\nclass Sifter{\n\n\tpublic items: any; // []|{};\n\tpublic settings: T.Settings;\n\n\t/**\n\t * Textually searches arrays and hashes of objects\n\t * by property (or multiple properties). Designed\n\t * specifically for autocomplete.\n\t *\n\t */\n\tconstructor(items:any, settings:T.Settings) {\n\t\tthis.items = items;\n\t\tthis.settings = settings || {diacritics: true};\n\t};\n\n\t/**\n\t * Splits a search string into an array of individual\n\t * regexps to be used to match results.\n\t *\n\t */\n\ttokenize(query:string, respect_word_boundaries?:boolean, weights?:T.Weights ):T.Token[] {\n\t\tif (!query || !query.length) return [];\n\n\t\tconst tokens:T.Token[]\t= [];\n\t\tconst words\t\t\t\t= query.split(/\\s+/);\n\t\tvar field_regex:RegExp;\n\n\t\tif( weights ){\n\t\t\tfield_regex = new RegExp( '^('+ Object.keys(weights).map(escape_regex).join('|')+')\\:(.*)$');\n\t\t}\n\n\t\twords.forEach((word:string) => {\n\t\t\tlet field_match;\n\t\t\tlet field:null|string\t= null;\n\t\t\tlet regex:null|string\t= null;\n\n\t\t\t// look for \"field:query\" tokens\n\t\t\tif( field_regex && (field_match = word.match(field_regex)) ){\n\t\t\t\tfield\t= field_match[1]!;\n\t\t\t\tword\t= field_match[2]!;\n\t\t\t}\n\n\t\t\tif( word.length > 0 ){\n\t\t\t\tif( this.settings.diacritics ){\n\t\t\t\t\tregex = getPattern(word) || null;\n\t\t\t\t}else{\n\t\t\t\t\tregex = escape_regex(word);\n\t\t\t\t}\n\t\t\t\tif( regex && respect_word_boundaries ) regex = \"\\\\b\"+regex;\n\t\t\t}\n\n\t\t\ttokens.push({\n\t\t\t\tstring : word,\n\t\t\t\tregex  : regex ? new RegExp(regex,'iu') : null,\n\t\t\t\tfield  : field,\n\t\t\t});\n\t\t});\n\n\t\treturn tokens;\n\t};\n\n\n\t/**\n\t * Returns a function to be used to score individual results.\n\t *\n\t * Good matches will have a higher score than poor matches.\n\t * If an item is not a match, 0 will be returned by the function.\n\t *\n\t * @returns {T.ScoreFn}\n\t */\n\tgetScoreFunction(query:string, options:T.UserOptions ){\n\t\tvar search = this.prepareSearch(query, options);\n\t\treturn this._getScoreFunction(search);\n\t}\n\n\t/**\n\t * @returns {T.ScoreFn}\n\t *\n\t */\n\t_getScoreFunction(search:T.PrepareObj ){\n\t\tconst tokens\t\t= search.tokens,\n\t\ttoken_count\t\t\t= tokens.length;\n\n\t\tif (!token_count) {\n\t\t\treturn function() { return 0; };\n\t\t}\n\n\t\tconst fields\t= search.options.fields,\n\t\tweights\t\t\t= search.weights,\n\t\tfield_count\t\t= fields.length,\n\t\tgetAttrFn\t\t= search.getAttrFn;\n\n\t\tif (!field_count) {\n\t\t\treturn function() { return 1; };\n\t\t}\n\n\n\t\t/**\n\t\t * Calculates the score of an object\n\t\t * against the search query.\n\t\t *\n\t\t */\n\t\tconst scoreObject = (function() {\n\n\n\t\t\tif (field_count === 1) {\n\t\t\t\treturn function(token:T.Token, data:{}) {\n\t\t\t\t\tconst field = fields[0]!.field;\n\t\t\t\t\treturn scoreValue(getAttrFn(data, field), token, weights[field]||1);\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn function(token:T.Token, data:{}) {\n\t\t\t\tvar sum = 0;\n\n\t\t\t\t// is the token specific to a field?\n\t\t\t\tif( token.field ){\n\n\t\t\t\t\tconst value = getAttrFn(data, token.field);\n\n\t\t\t\t\tif( !token.regex && value ){\n\t\t\t\t\t\tsum += (1/field_count);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsum += scoreValue(value, token, 1);\n\t\t\t\t\t}\n\n\n\n\t\t\t\t}else{\n\t\t\t\t\titerate(weights, (weight:number, field:string) => {\n\t\t\t\t\t\tsum += scoreValue(getAttrFn(data, field), token, weight);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn sum / field_count;\n\t\t\t};\n\t\t})();\n\n\t\tif (token_count === 1) {\n\t\t\treturn function(data:{}) {\n\t\t\t\treturn scoreObject(tokens[0]!, data);\n\t\t\t};\n\t\t}\n\n\t\tif (search.options.conjunction === 'and') {\n\t\t\treturn function(data:{}) {\n\t\t\t\tvar score, sum = 0;\n\t\t\t\tfor( let token of tokens){\n\t\t\t\t\tscore = scoreObject(token, data);\n\t\t\t\t\tif (score <= 0) return 0;\n\t\t\t\t\tsum += score;\n\t\t\t\t}\n\t\t\t\treturn sum / token_count;\n\t\t\t};\n\t\t} else {\n\t\t\treturn function(data:{}) {\n\t\t\t\tvar sum = 0;\n\t\t\t\titerate(tokens,(token:T.Token)=>{\n\t\t\t\t\tsum += scoreObject(token, data);\n\t\t\t\t});\n\t\t\t\treturn sum / token_count;\n\t\t\t};\n\t\t}\n\t};\n\n\t/**\n\t * Returns a function that can be used to compare two\n\t * results, for sorting purposes. If no sorting should\n\t * be performed, `null` will be returned.\n\t *\n\t * @return function(a,b)\n\t */\n\tgetSortFunction(query:string, options:T.UserOptions) {\n\t\tvar search  = this.prepareSearch(query, options);\n\t\treturn this._getSortFunction(search);\n\t}\n\n\t_getSortFunction(search:T.PrepareObj){\n\t\tvar implicit_score,\n\t\tsort_flds:T.Sort[]\t= [];\n\n\t\tconst self\t= this,\n\t\toptions\t\t= search.options,\n\t\tsort\t\t= (!search.query && options.sort_empty) ? options.sort_empty : options.sort;\n\n\n\t\tif( typeof sort == 'function' ){\n\t\t\treturn sort.bind(this);\n\t\t}\n\n\t\t/**\n\t\t * Fetches the specified sort field value\n\t\t * from a search result item.\n\t\t *\n\t\t */\n\t\tconst get_field = function(name:string, result:T.ResultItem):string|number {\n\t\t\tif (name === '$score') return result.score;\n\t\t\treturn search.getAttrFn(self.items[result.id], name);\n\t\t};\n\n\t\t// parse options\n\t\tif (sort) {\n\t\t\tfor( let s of sort ){\n\t\t\t\tif (search.query || s.field !== '$score') {\n\t\t\t\t\tsort_flds.push(s);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// the \"$score\" field is implied to be the primary\n\t\t// sort field, unless it's manually specified\n\t\tif (search.query) {\n\t\t\timplicit_score = true;\n\t\t\tfor( let fld of sort_flds ){\n\t\t\t\tif( fld.field === '$score' ){\n\t\t\t\t\timplicit_score = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (implicit_score) {\n\t\t\t\tsort_flds.unshift({field: '$score', direction: 'desc'});\n\t\t\t}\n\n\t\t// without a search.query, all items will have the same score\n\t\t} else {\n\t\t\tsort_flds = sort_flds.filter((fld) => fld.field !== '$score' );\n\t\t}\n\n\n\t\t// build function\n\t\tconst sort_flds_count = sort_flds.length;\n\t\tif (!sort_flds_count) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn function(a:T.ResultItem, b:T.ResultItem) {\n\t\t\tvar result, field;\n\t\t\tfor( let sort_fld of sort_flds ){\n\t\t\t\tfield = sort_fld.field;\n\n\t\t\t\tlet\tmultiplier = sort_fld.direction === 'desc' ? -1 : 1;\n\n\t\t\t\tresult = multiplier * cmp(\n\t\t\t\t\tget_field(field, a),\n\t\t\t\t\tget_field(field, b)\n\t\t\t\t);\n\t\t\t\tif (result) return result;\n\t\t\t}\n\t\t\treturn 0;\n\t\t};\n\n\t};\n\n\t/**\n\t * Parses a search query and returns an object\n\t * with tokens and fields ready to be populated\n\t * with results.\n\t *\n\t */\n\tprepareSearch(query:string, optsUser:T.UserOptions):T.PrepareObj {\n\t\tconst weights:T.Weights = {};\n\t\tvar options\t\t= Object.assign({},optsUser) as T.Options;\n\n\t\tpropToArray(options,'sort');\n\t\tpropToArray(options,'sort_empty');\n\n\t\t// convert fields to new format\n\t\tif( options.fields ){\n\t\t\tpropToArray(options,'fields');\n\t\t\tconst fields:T.Field[] = [];\n\t\t\toptions.fields.forEach((field:string|T.Field) => {\n\t\t\t\tif( typeof field == 'string' ){\n\t\t\t\t\tfield = {field:field,weight:1};\n\t\t\t\t}\n\t\t\t\tfields.push(field);\n\t\t\t\tweights[field.field] = ('weight' in field) ? field.weight : 1;\n\t\t\t});\n\t\t\toptions.fields = fields;\n\t\t}\n\n\n\t\treturn {\n\t\t\toptions\t\t: options as T.Options,\n\t\t\tquery\t\t: query.toLowerCase().trim(),\n\t\t\ttokens\t\t: this.tokenize(query, options.respect_word_boundaries, weights),\n\t\t\ttotal\t\t: 0,\n\t\t\titems\t\t: [],\n\t\t\tweights\t\t: weights,\n\t\t\tgetAttrFn\t: (options.nesting) ? getAttrNesting : getAttr,\n\t\t};\n\t};\n\n\t/**\n\t * Searches through all items and returns a sorted array of matches.\n\t *\n\t */\n\tsearch(query:string, options:T.UserOptions) : T.PrepareObj {\n\t\tvar self = this, score, search: T.PrepareObj;\n\n\t\tsearch  = this.prepareSearch(query, options);\n\t\toptions = search.options;\n\t\tquery   = search.query;\n\n\t\t// generate result scoring function\n\t\tconst fn_score:T.ScoreFn = options.score || self._getScoreFunction(search);\n\n\t\t// perform search and sort\n\t\tif (query.length) {\n\t\t\titerate(self.items, (item:T.ResultItem, id:string|number) => {\n\t\t\t\tscore = fn_score(item);\n\t\t\t\tif (options.filter === false || score > 0) {\n\t\t\t\t\tsearch.items.push({'score': score, 'id': id});\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\titerate(self.items, (_:T.ResultItem, id:string|number) => {\n\t\t\t\tsearch.items.push({'score': 1, 'id': id});\n\t\t\t});\n\t\t}\n\n\t\tconst fn_sort = self._getSortFunction(search);\n\t\tif (fn_sort) search.items.sort(fn_sort);\n\n\t\t// apply limits\n\t\tsearch.total = search.items.length;\n\t\tif (typeof options.limit === 'number') {\n\t\t\tsearch.items = search.items.slice(0, options.limit);\n\t\t}\n\n\t\treturn search;\n\t};\n}\n\nexport { Sifter, scoreValue, getAttr, getAttrNesting, propToArray, iterate, cmp, getPattern }\nexport * from './types.ts';\n"],"names":["arrayToPattern","chars","filter","Boolean","length","maxValueLength","join","sequencePattern","array","hasDuplicates","pattern","prev_char_count","prev_pattern","forEach","char","i","setToPattern","Array","from","Set","size","escape_regex","str","replace","reduce","longest","value","Math","max","unicodeLength","allSubstrings","input","result","start","substring","suba","subresult","tmp","slice","charAt","push","unshift","code_points","accent_pat","unicode_map","multi_char_reg","max_char_length","latin_convert","latin_condensed","latin","unicode","convert_pat","RegExp","Object","keys","initialize","_code_points","undefined","generateMap","normalize","form","asciifold","_asciifold","toLowerCase","generator","code_point_min","code_point_max","composed","String","fromCharCode","folded","code_point","generateSets","unicode_sets","addMatching","to_add","folded_set","patt","match","add","multi_char","set","sort","a","b","multi_char_patt","mapSequence","strings","min_replacement","chars_replaced","map","substringsToPattern","sub_pat","sequencesToPattern","sequences","all","sequence","seq","len","j","substrs","inSequences","needle_seq","end","needle_parts","parts","part","needle_part","substr","filtered","Sequence","constructor","min","last","clone","position","last_piece","JSON","parse","stringify","last_part","pop","last_substr","clone_last_len","getPattern","match_str","overlapping","added_types","has","new_seq","old_seq","getAttr","obj","name","getAttrNesting","names","split","shift","scoreValue","token","weight","score","pos","regex","search","string","propToArray","key","isArray","iterate","object","callback","hasOwnProperty","cmp","Sifter","items","settings","diacritics","tokenize","query","respect_word_boundaries","weights","tokens","words","field_regex","word","field_match","field","getScoreFunction","options","prepareSearch","_getScoreFunction","token_count","fields","field_count","getAttrFn","scoreObject","data","sum","conjunction","getSortFunction","_getSortFunction","implicit_score","sort_flds","self","sort_empty","bind","get_field","id","s","fld","direction","sort_flds_count","sort_fld","multiplier","optsUser","assign","trim","total","nesting","fn_score","item","_","fn_sort","limit"],"mappings":"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","x_google_ignoreList":[0,1,2]}