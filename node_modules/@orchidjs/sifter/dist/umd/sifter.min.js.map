{"version":3,"file":"sifter.min.js","sources":["../../node_modules/@orchidjs/unicode-variants/dist/esm/regex.js","../../node_modules/@orchidjs/unicode-variants/dist/esm/strings.js","../../node_modules/@orchidjs/unicode-variants/dist/esm/index.js","../../lib/utils.ts","../../lib/sifter.ts"],"sourcesContent":["/**\n * Convert array of strings to a regular expression\n *\tex ['ab','a'] => (?:ab|a)\n * \tex ['a','b'] => [ab]\n */\nexport const arrayToPattern = (chars) => {\n    chars = chars.filter(Boolean);\n    if (chars.length < 2) {\n        return chars[0] || '';\n    }\n    return (maxValueLength(chars) == 1) ? '[' + chars.join('') + ']' : '(?:' + chars.join('|') + ')';\n};\nexport const sequencePattern = (array) => {\n    if (!hasDuplicates(array)) {\n        return array.join('');\n    }\n    let pattern = '';\n    let prev_char_count = 0;\n    const prev_pattern = () => {\n        if (prev_char_count > 1) {\n            pattern += '{' + prev_char_count + '}';\n        }\n    };\n    array.forEach((char, i) => {\n        if (char === array[i - 1]) {\n            prev_char_count++;\n            return;\n        }\n        prev_pattern();\n        pattern += char;\n        prev_char_count = 1;\n    });\n    prev_pattern();\n    return pattern;\n};\n/**\n * Convert array of strings to a regular expression\n *\tex ['ab','a'] => (?:ab|a)\n * \tex ['a','b'] => [ab]\n */\nexport const setToPattern = (chars) => {\n    let array = Array.from(chars);\n    return arrayToPattern(array);\n};\n/**\n * https://stackoverflow.com/questions/7376598/in-javascript-how-do-i-check-if-an-array-has-duplicate-values\n */\nexport const hasDuplicates = (array) => {\n    return (new Set(array)).size !== array.length;\n};\n/**\n * https://stackoverflow.com/questions/63006601/why-does-u-throw-an-invalid-escape-error\n */\nexport const escape_regex = (str) => {\n    return (str + '').replace(/([\\$\\(\\)\\*\\+\\.\\?\\[\\]\\^\\{\\|\\}\\\\])/gu, '\\\\$1');\n};\n/**\n * Return the max length of array values\n */\nexport const maxValueLength = (array) => {\n    return array.reduce((longest, value) => Math.max(longest, unicodeLength(value)), 0);\n};\nexport const unicodeLength = (str) => {\n    return Array.from(str).length;\n};\n//# sourceMappingURL=regex.js.map","/**\n * Get all possible combinations of substrings that add up to the given string\n * https://stackoverflow.com/questions/30169587/find-all-the-combination-of-substrings-that-add-up-to-the-given-string\n */\nexport const allSubstrings = (input) => {\n    if (input.length === 1)\n        return [[input]];\n    let result = [];\n    const start = input.substring(1);\n    const suba = allSubstrings(start);\n    suba.forEach(function (subresult) {\n        let tmp = subresult.slice(0);\n        tmp[0] = input.charAt(0) + tmp[0];\n        result.push(tmp);\n        tmp = subresult.slice(0);\n        tmp.unshift(input.charAt(0));\n        result.push(tmp);\n    });\n    return result;\n};\n//# sourceMappingURL=strings.js.map","import { setToPattern, arrayToPattern, escape_regex, sequencePattern } from \"./regex.js\";\nimport { allSubstrings } from \"./strings.js\";\nexport const code_points = [[0, 65535]];\nconst accent_pat = '[\\u0300-\\u036F\\u{b7}\\u{2be}\\u{2bc}]';\nexport let unicode_map;\nlet multi_char_reg;\nconst max_char_length = 3;\nconst latin_convert = {};\nconst latin_condensed = {\n    '/': '⁄∕',\n    '0': '߀',\n    \"a\": \"ⱥɐɑ\",\n    \"aa\": \"ꜳ\",\n    \"ae\": \"æǽǣ\",\n    \"ao\": \"ꜵ\",\n    \"au\": \"ꜷ\",\n    \"av\": \"ꜹꜻ\",\n    \"ay\": \"ꜽ\",\n    \"b\": \"ƀɓƃ\",\n    \"c\": \"ꜿƈȼↄ\",\n    \"d\": \"đɗɖᴅƌꮷԁɦ\",\n    \"e\": \"ɛǝᴇɇ\",\n    \"f\": \"ꝼƒ\",\n    \"g\": \"ǥɠꞡᵹꝿɢ\",\n    \"h\": \"ħⱨⱶɥ\",\n    \"i\": \"ɨı\",\n    \"j\": \"ɉȷ\",\n    \"k\": \"ƙⱪꝁꝃꝅꞣ\",\n    \"l\": \"łƚɫⱡꝉꝇꞁɭ\",\n    \"m\": \"ɱɯϻ\",\n    \"n\": \"ꞥƞɲꞑᴎлԉ\",\n    \"o\": \"øǿɔɵꝋꝍᴑ\",\n    \"oe\": \"œ\",\n    \"oi\": \"ƣ\",\n    \"oo\": \"ꝏ\",\n    \"ou\": \"ȣ\",\n    \"p\": \"ƥᵽꝑꝓꝕρ\",\n    \"q\": \"ꝗꝙɋ\",\n    \"r\": \"ɍɽꝛꞧꞃ\",\n    \"s\": \"ßȿꞩꞅʂ\",\n    \"t\": \"ŧƭʈⱦꞇ\",\n    \"th\": \"þ\",\n    \"tz\": \"ꜩ\",\n    \"u\": \"ʉ\",\n    \"v\": \"ʋꝟʌ\",\n    \"vy\": \"ꝡ\",\n    \"w\": \"ⱳ\",\n    \"y\": \"ƴɏỿ\",\n    \"z\": \"ƶȥɀⱬꝣ\",\n    \"hv\": \"ƕ\"\n};\nfor (let latin in latin_condensed) {\n    let unicode = latin_condensed[latin] || '';\n    for (let i = 0; i < unicode.length; i++) {\n        let char = unicode.substring(i, i + 1);\n        latin_convert[char] = latin;\n    }\n}\nconst convert_pat = new RegExp(Object.keys(latin_convert).join('|') + '|' + accent_pat, 'gu');\n/**\n * Initialize the unicode_map from the give code point ranges\n */\nexport const initialize = (_code_points) => {\n    if (unicode_map !== undefined)\n        return;\n    unicode_map = generateMap(_code_points || code_points);\n};\n/**\n * Helper method for normalize a string\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize\n */\nexport const normalize = (str, form = 'NFKD') => str.normalize(form);\n/**\n * Remove accents without reordering string\n * calling str.normalize('NFKD') on \\u{594}\\u{595}\\u{596} becomes \\u{596}\\u{594}\\u{595}\n * via https://github.com/krisk/Fuse/issues/133#issuecomment-318692703\n */\nexport const asciifold = (str) => {\n    return Array.from(str).reduce(\n    /**\n     * @param {string} result\n     * @param {string} char\n     */\n    (result, char) => {\n        return result + _asciifold(char);\n    }, '');\n};\nexport const _asciifold = (str) => {\n    str = normalize(str)\n        .toLowerCase()\n        .replace(convert_pat, (/** @type {string} */ char) => {\n        return latin_convert[char] || '';\n    });\n    //return str;\n    return normalize(str, 'NFC');\n};\n/**\n * Generate a list of unicode variants from the list of code points\n */\nexport function* generator(code_points) {\n    for (const [code_point_min, code_point_max] of code_points) {\n        for (let i = code_point_min; i <= code_point_max; i++) {\n            let composed = String.fromCharCode(i);\n            let folded = asciifold(composed);\n            if (folded == composed.toLowerCase()) {\n                continue;\n            }\n            // skip when folded is a string longer than 3 characters long\n            // bc the resulting regex patterns will be long\n            // eg:\n            // folded صلى الله عليه وسلم length 18 code point 65018\n            // folded جل جلاله length 8 code point 65019\n            if (folded.length > max_char_length) {\n                continue;\n            }\n            if (folded.length == 0) {\n                continue;\n            }\n            yield { folded: folded, composed: composed, code_point: i };\n        }\n    }\n}\n/**\n * Generate a unicode map from the list of code points\n */\nexport const generateSets = (code_points) => {\n    const unicode_sets = {};\n    const addMatching = (folded, to_add) => {\n        /** @type {Set<string>} */\n        const folded_set = unicode_sets[folded] || new Set();\n        const patt = new RegExp('^' + setToPattern(folded_set) + '$', 'iu');\n        if (to_add.match(patt)) {\n            return;\n        }\n        folded_set.add(escape_regex(to_add));\n        unicode_sets[folded] = folded_set;\n    };\n    for (let value of generator(code_points)) {\n        addMatching(value.folded, value.folded);\n        addMatching(value.folded, value.composed);\n    }\n    return unicode_sets;\n};\n/**\n * Generate a unicode map from the list of code points\n * ae => (?:(?:ae|Æ|Ǽ|Ǣ)|(?:A|Ⓐ|Ａ...)(?:E|ɛ|Ⓔ...))\n */\nexport const generateMap = (code_points) => {\n    const unicode_sets = generateSets(code_points);\n    const unicode_map = {};\n    let multi_char = [];\n    for (let folded in unicode_sets) {\n        let set = unicode_sets[folded];\n        if (set) {\n            unicode_map[folded] = setToPattern(set);\n        }\n        if (folded.length > 1) {\n            multi_char.push(escape_regex(folded));\n        }\n    }\n    multi_char.sort((a, b) => b.length - a.length);\n    const multi_char_patt = arrayToPattern(multi_char);\n    multi_char_reg = new RegExp('^' + multi_char_patt, 'u');\n    return unicode_map;\n};\n/**\n * Map each element of an array from its folded value to all possible unicode matches\n */\nexport const mapSequence = (strings, min_replacement = 1) => {\n    let chars_replaced = 0;\n    strings = strings.map((str) => {\n        if (unicode_map[str]) {\n            chars_replaced += str.length;\n        }\n        return unicode_map[str] || str;\n    });\n    if (chars_replaced >= min_replacement) {\n        return sequencePattern(strings);\n    }\n    return '';\n};\n/**\n * Convert a short string and split it into all possible patterns\n * Keep a pattern only if min_replacement is met\n *\n * 'abc'\n * \t\t=> [['abc'],['ab','c'],['a','bc'],['a','b','c']]\n *\t\t=> ['abc-pattern','ab-c-pattern'...]\n */\nexport const substringsToPattern = (str, min_replacement = 1) => {\n    min_replacement = Math.max(min_replacement, str.length - 1);\n    return arrayToPattern(allSubstrings(str).map((sub_pat) => {\n        return mapSequence(sub_pat, min_replacement);\n    }));\n};\n/**\n * Convert an array of sequences into a pattern\n * [{start:0,end:3,length:3,substr:'iii'}...] => (?:iii...)\n */\nconst sequencesToPattern = (sequences, all = true) => {\n    let min_replacement = sequences.length > 1 ? 1 : 0;\n    return arrayToPattern(sequences.map((sequence) => {\n        let seq = [];\n        const len = all ? sequence.length() : sequence.length() - 1;\n        for (let j = 0; j < len; j++) {\n            seq.push(substringsToPattern(sequence.substrs[j] || '', min_replacement));\n        }\n        return sequencePattern(seq);\n    }));\n};\n/**\n * Return true if the sequence is already in the sequences\n */\nconst inSequences = (needle_seq, sequences) => {\n    for (const seq of sequences) {\n        if (seq.start != needle_seq.start || seq.end != needle_seq.end) {\n            continue;\n        }\n        if (seq.substrs.join('') !== needle_seq.substrs.join('')) {\n            continue;\n        }\n        let needle_parts = needle_seq.parts;\n        const filter = (part) => {\n            for (const needle_part of needle_parts) {\n                if (needle_part.start === part.start && needle_part.substr === part.substr) {\n                    return false;\n                }\n                if (part.length == 1 || needle_part.length == 1) {\n                    continue;\n                }\n                // check for overlapping parts\n                // a = ['::=','==']\n                // b = ['::','===']\n                // a = ['r','sm']\n                // b = ['rs','m']\n                if (part.start < needle_part.start && part.end > needle_part.start) {\n                    return true;\n                }\n                if (needle_part.start < part.start && needle_part.end > part.start) {\n                    return true;\n                }\n            }\n            return false;\n        };\n        let filtered = seq.parts.filter(filter);\n        if (filtered.length > 0) {\n            continue;\n        }\n        return true;\n    }\n    return false;\n};\nclass Sequence {\n    parts;\n    substrs;\n    start;\n    end;\n    constructor() {\n        this.parts = [];\n        this.substrs = [];\n        this.start = 0;\n        this.end = 0;\n    }\n    add(part) {\n        if (part) {\n            this.parts.push(part);\n            this.substrs.push(part.substr);\n            this.start = Math.min(part.start, this.start);\n            this.end = Math.max(part.end, this.end);\n        }\n    }\n    last() {\n        return this.parts[this.parts.length - 1];\n    }\n    length() {\n        return this.parts.length;\n    }\n    clone(position, last_piece) {\n        let clone = new Sequence();\n        let parts = JSON.parse(JSON.stringify(this.parts));\n        let last_part = parts.pop();\n        for (const part of parts) {\n            clone.add(part);\n        }\n        let last_substr = last_piece.substr.substring(0, position - last_part.start);\n        let clone_last_len = last_substr.length;\n        clone.add({ start: last_part.start, end: last_part.start + clone_last_len, length: clone_last_len, substr: last_substr });\n        return clone;\n    }\n}\n/**\n * Expand a regular expression pattern to include unicode variants\n * \teg /a/ becomes /aⓐａẚàáâầấẫẩãāăằắẵẳȧǡäǟảåǻǎȁȃạậặḁąⱥɐɑAⒶＡÀÁÂẦẤẪẨÃĀĂẰẮẴẲȦǠÄǞẢÅǺǍȀȂẠẬẶḀĄȺⱯ/\n *\n * Issue:\n *  ﺊﺋ [ 'ﺊ = \\\\u{fe8a}', 'ﺋ = \\\\u{fe8b}' ]\n *\tbecomes:\tئئ [ 'ي = \\\\u{64a}', 'ٔ = \\\\u{654}', 'ي = \\\\u{64a}', 'ٔ = \\\\u{654}' ]\n *\n *\tİĲ = IIJ = ⅡJ\n *\n * \t1/2/4\n */\nexport const getPattern = (str) => {\n    initialize();\n    str = asciifold(str);\n    let pattern = '';\n    let sequences = [new Sequence()];\n    for (let i = 0; i < str.length; i++) {\n        let substr = str.substring(i);\n        let match = substr.match(multi_char_reg);\n        const char = str.substring(i, i + 1);\n        const match_str = match ? match[0] : null;\n        // loop through sequences\n        // add either the char or multi_match\n        let overlapping = [];\n        let added_types = new Set();\n        for (const sequence of sequences) {\n            const last_piece = sequence.last();\n            if (!last_piece || last_piece.length == 1 || last_piece.end <= i) {\n                // if we have a multi match\n                if (match_str) {\n                    const len = match_str.length;\n                    sequence.add({ start: i, end: i + len, length: len, substr: match_str });\n                    added_types.add('1');\n                }\n                else {\n                    sequence.add({ start: i, end: i + 1, length: 1, substr: char });\n                    added_types.add('2');\n                }\n            }\n            else if (match_str) {\n                let clone = sequence.clone(i, last_piece);\n                const len = match_str.length;\n                clone.add({ start: i, end: i + len, length: len, substr: match_str });\n                overlapping.push(clone);\n            }\n            else {\n                // don't add char\n                // adding would create invalid patterns: 234 => [2,34,4]\n                added_types.add('3');\n            }\n        }\n        // if we have overlapping\n        if (overlapping.length > 0) {\n            // ['ii','iii'] before ['i','i','iii']\n            overlapping = overlapping.sort((a, b) => {\n                return a.length() - b.length();\n            });\n            for (let clone of overlapping) {\n                // don't add if we already have an equivalent sequence\n                if (inSequences(clone, sequences)) {\n                    continue;\n                }\n                sequences.push(clone);\n            }\n            continue;\n        }\n        // if we haven't done anything unique\n        // clean up the patterns\n        // helps keep patterns smaller\n        // if str = 'r₨㎧aarss', pattern will be 446 instead of 655\n        if (i > 0 && added_types.size == 1 && !added_types.has('3')) {\n            pattern += sequencesToPattern(sequences, false);\n            let new_seq = new Sequence();\n            const old_seq = sequences[0];\n            if (old_seq) {\n                new_seq.add(old_seq.last());\n            }\n            sequences = [new_seq];\n        }\n    }\n    pattern += sequencesToPattern(sequences, true);\n    return pattern;\n};\nexport { escape_regex };\n//# sourceMappingURL=index.js.map","\nimport { asciifold } from '@orchidjs/unicode-variants';\nimport * as T from './types.ts';\n\n\n/**\n * A property getter resolving dot-notation\n * @param  {Object}  obj     The root object to fetch property on\n * @param  {String}  name    The optionally dotted property name to fetch\n * @return {Object}          The resolved property value\n */\nexport const getAttr = (obj:{[key:string]:any}, name:string ) => {\n    if (!obj ) return;\n    return obj[name];\n};\n\n/**\n * A property getter resolving dot-notation\n * @param  {Object}  obj     The root object to fetch property on\n * @param  {String}  name    The optionally dotted property name to fetch\n * @return {Object}          The resolved property value\n */\nexport const getAttrNesting = (obj:{[key:string]:any}, name:string ) => {\n    if (!obj ) return;\n    var part, names = name.split(\".\");\n\twhile( (part = names.shift()) && (obj = obj[part]));\n    return obj;\n};\n\n/**\n * Calculates how close of a match the\n * given value is against a search token.\n *\n */\nexport const scoreValue = (value:string, token:T.Token, weight:number ):number => {\n\tvar score, pos;\n\n\tif (!value) return 0;\n\n\tvalue = value + '';\n\tif( token.regex == null ) return 0;\n\tpos = value.search(token.regex);\n\tif (pos === -1) return 0;\n\n\tscore = token.string.length / value.length;\n\tif (pos === 0) score += 0.5;\n\n\treturn score * weight;\n};\n\n\n/**\n * Cast object property to an array if it exists and has a value\n *\n */\nexport const propToArray = (obj:{[key:string]:any}, key:string) => {\n\tvar value = obj[key];\n\n\tif( typeof value == 'function' ) return value;\n\n\tif( value && !Array.isArray(value) ){\n\t\tobj[key] = [value];\n\t}\n}\n\n\n/**\n * Iterates over arrays and hashes.\n *\n * ```\n * iterate(this.items, function(item, id) {\n *    // invoked for each item\n * });\n * ```\n *\n */\nexport const iterate = (object:[]|{[key:string]:any}, callback:(value:any,key:any)=>any) => {\n\n\tif ( Array.isArray(object)) {\n\t\tobject.forEach(callback);\n\n\t}else{\n\n\t\tfor (var key in object) {\n\t\t\tif (object.hasOwnProperty(key)) {\n\t\t\t\tcallback(object[key], key);\n\t\t\t}\n\t\t}\n\t}\n};\n\n\n\nexport const cmp = (a:number|string, b:number|string) => {\n\tif (typeof a === 'number' && typeof b === 'number') {\n\t\treturn a > b ? 1 : (a < b ? -1 : 0);\n\t}\n\ta = asciifold(a + '').toLowerCase();\n\tb = asciifold(b + '').toLowerCase();\n\tif (a > b) return 1;\n\tif (b > a) return -1;\n\treturn 0;\n};\n","/**\n * sifter.js\n * Copyright (c) 2013–2020 Brian Reavis & contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this\n * file except in compliance with the License. You may obtain a copy of the License at:\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n * ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n *\n * @author Brian Reavis <brian@thirdroute.com>\n */\n\nimport { scoreValue, getAttr, getAttrNesting, propToArray, iterate, cmp } from './utils.ts';\nimport { getPattern, escape_regex } from '@orchidjs/unicode-variants';\nimport * as T from './types.ts';\n\nclass Sifter{\n\n\tpublic items: any; // []|{};\n\tpublic settings: T.Settings;\n\n\t/**\n\t * Textually searches arrays and hashes of objects\n\t * by property (or multiple properties). Designed\n\t * specifically for autocomplete.\n\t *\n\t */\n\tconstructor(items:any, settings:T.Settings) {\n\t\tthis.items = items;\n\t\tthis.settings = settings || {diacritics: true};\n\t};\n\n\t/**\n\t * Splits a search string into an array of individual\n\t * regexps to be used to match results.\n\t *\n\t */\n\ttokenize(query:string, respect_word_boundaries?:boolean, weights?:T.Weights ):T.Token[] {\n\t\tif (!query || !query.length) return [];\n\n\t\tconst tokens:T.Token[]\t= [];\n\t\tconst words\t\t\t\t= query.split(/\\s+/);\n\t\tvar field_regex:RegExp;\n\n\t\tif( weights ){\n\t\t\tfield_regex = new RegExp( '^('+ Object.keys(weights).map(escape_regex).join('|')+')\\:(.*)$');\n\t\t}\n\n\t\twords.forEach((word:string) => {\n\t\t\tlet field_match;\n\t\t\tlet field:null|string\t= null;\n\t\t\tlet regex:null|string\t= null;\n\n\t\t\t// look for \"field:query\" tokens\n\t\t\tif( field_regex && (field_match = word.match(field_regex)) ){\n\t\t\t\tfield\t= field_match[1]!;\n\t\t\t\tword\t= field_match[2]!;\n\t\t\t}\n\n\t\t\tif( word.length > 0 ){\n\t\t\t\tif( this.settings.diacritics ){\n\t\t\t\t\tregex = getPattern(word) || null;\n\t\t\t\t}else{\n\t\t\t\t\tregex = escape_regex(word);\n\t\t\t\t}\n\t\t\t\tif( regex && respect_word_boundaries ) regex = \"\\\\b\"+regex;\n\t\t\t}\n\n\t\t\ttokens.push({\n\t\t\t\tstring : word,\n\t\t\t\tregex  : regex ? new RegExp(regex,'iu') : null,\n\t\t\t\tfield  : field,\n\t\t\t});\n\t\t});\n\n\t\treturn tokens;\n\t};\n\n\n\t/**\n\t * Returns a function to be used to score individual results.\n\t *\n\t * Good matches will have a higher score than poor matches.\n\t * If an item is not a match, 0 will be returned by the function.\n\t *\n\t * @returns {T.ScoreFn}\n\t */\n\tgetScoreFunction(query:string, options:T.UserOptions ){\n\t\tvar search = this.prepareSearch(query, options);\n\t\treturn this._getScoreFunction(search);\n\t}\n\n\t/**\n\t * @returns {T.ScoreFn}\n\t *\n\t */\n\t_getScoreFunction(search:T.PrepareObj ){\n\t\tconst tokens\t\t= search.tokens,\n\t\ttoken_count\t\t\t= tokens.length;\n\n\t\tif (!token_count) {\n\t\t\treturn function() { return 0; };\n\t\t}\n\n\t\tconst fields\t= search.options.fields,\n\t\tweights\t\t\t= search.weights,\n\t\tfield_count\t\t= fields.length,\n\t\tgetAttrFn\t\t= search.getAttrFn;\n\n\t\tif (!field_count) {\n\t\t\treturn function() { return 1; };\n\t\t}\n\n\n\t\t/**\n\t\t * Calculates the score of an object\n\t\t * against the search query.\n\t\t *\n\t\t */\n\t\tconst scoreObject = (function() {\n\n\n\t\t\tif (field_count === 1) {\n\t\t\t\treturn function(token:T.Token, data:{}) {\n\t\t\t\t\tconst field = fields[0]!.field;\n\t\t\t\t\treturn scoreValue(getAttrFn(data, field), token, weights[field]||1);\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn function(token:T.Token, data:{}) {\n\t\t\t\tvar sum = 0;\n\n\t\t\t\t// is the token specific to a field?\n\t\t\t\tif( token.field ){\n\n\t\t\t\t\tconst value = getAttrFn(data, token.field);\n\n\t\t\t\t\tif( !token.regex && value ){\n\t\t\t\t\t\tsum += (1/field_count);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsum += scoreValue(value, token, 1);\n\t\t\t\t\t}\n\n\n\n\t\t\t\t}else{\n\t\t\t\t\titerate(weights, (weight:number, field:string) => {\n\t\t\t\t\t\tsum += scoreValue(getAttrFn(data, field), token, weight);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn sum / field_count;\n\t\t\t};\n\t\t})();\n\n\t\tif (token_count === 1) {\n\t\t\treturn function(data:{}) {\n\t\t\t\treturn scoreObject(tokens[0]!, data);\n\t\t\t};\n\t\t}\n\n\t\tif (search.options.conjunction === 'and') {\n\t\t\treturn function(data:{}) {\n\t\t\t\tvar score, sum = 0;\n\t\t\t\tfor( let token of tokens){\n\t\t\t\t\tscore = scoreObject(token, data);\n\t\t\t\t\tif (score <= 0) return 0;\n\t\t\t\t\tsum += score;\n\t\t\t\t}\n\t\t\t\treturn sum / token_count;\n\t\t\t};\n\t\t} else {\n\t\t\treturn function(data:{}) {\n\t\t\t\tvar sum = 0;\n\t\t\t\titerate(tokens,(token:T.Token)=>{\n\t\t\t\t\tsum += scoreObject(token, data);\n\t\t\t\t});\n\t\t\t\treturn sum / token_count;\n\t\t\t};\n\t\t}\n\t};\n\n\t/**\n\t * Returns a function that can be used to compare two\n\t * results, for sorting purposes. If no sorting should\n\t * be performed, `null` will be returned.\n\t *\n\t * @return function(a,b)\n\t */\n\tgetSortFunction(query:string, options:T.UserOptions) {\n\t\tvar search  = this.prepareSearch(query, options);\n\t\treturn this._getSortFunction(search);\n\t}\n\n\t_getSortFunction(search:T.PrepareObj){\n\t\tvar implicit_score,\n\t\tsort_flds:T.Sort[]\t= [];\n\n\t\tconst self\t= this,\n\t\toptions\t\t= search.options,\n\t\tsort\t\t= (!search.query && options.sort_empty) ? options.sort_empty : options.sort;\n\n\n\t\tif( typeof sort == 'function' ){\n\t\t\treturn sort.bind(this);\n\t\t}\n\n\t\t/**\n\t\t * Fetches the specified sort field value\n\t\t * from a search result item.\n\t\t *\n\t\t */\n\t\tconst get_field = function(name:string, result:T.ResultItem):string|number {\n\t\t\tif (name === '$score') return result.score;\n\t\t\treturn search.getAttrFn(self.items[result.id], name);\n\t\t};\n\n\t\t// parse options\n\t\tif (sort) {\n\t\t\tfor( let s of sort ){\n\t\t\t\tif (search.query || s.field !== '$score') {\n\t\t\t\t\tsort_flds.push(s);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// the \"$score\" field is implied to be the primary\n\t\t// sort field, unless it's manually specified\n\t\tif (search.query) {\n\t\t\timplicit_score = true;\n\t\t\tfor( let fld of sort_flds ){\n\t\t\t\tif( fld.field === '$score' ){\n\t\t\t\t\timplicit_score = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (implicit_score) {\n\t\t\t\tsort_flds.unshift({field: '$score', direction: 'desc'});\n\t\t\t}\n\n\t\t// without a search.query, all items will have the same score\n\t\t} else {\n\t\t\tsort_flds = sort_flds.filter((fld) => fld.field !== '$score' );\n\t\t}\n\n\n\t\t// build function\n\t\tconst sort_flds_count = sort_flds.length;\n\t\tif (!sort_flds_count) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn function(a:T.ResultItem, b:T.ResultItem) {\n\t\t\tvar result, field;\n\t\t\tfor( let sort_fld of sort_flds ){\n\t\t\t\tfield = sort_fld.field;\n\n\t\t\t\tlet\tmultiplier = sort_fld.direction === 'desc' ? -1 : 1;\n\n\t\t\t\tresult = multiplier * cmp(\n\t\t\t\t\tget_field(field, a),\n\t\t\t\t\tget_field(field, b)\n\t\t\t\t);\n\t\t\t\tif (result) return result;\n\t\t\t}\n\t\t\treturn 0;\n\t\t};\n\n\t};\n\n\t/**\n\t * Parses a search query and returns an object\n\t * with tokens and fields ready to be populated\n\t * with results.\n\t *\n\t */\n\tprepareSearch(query:string, optsUser:T.UserOptions):T.PrepareObj {\n\t\tconst weights:T.Weights = {};\n\t\tvar options\t\t= Object.assign({},optsUser) as T.Options;\n\n\t\tpropToArray(options,'sort');\n\t\tpropToArray(options,'sort_empty');\n\n\t\t// convert fields to new format\n\t\tif( options.fields ){\n\t\t\tpropToArray(options,'fields');\n\t\t\tconst fields:T.Field[] = [];\n\t\t\toptions.fields.forEach((field:string|T.Field) => {\n\t\t\t\tif( typeof field == 'string' ){\n\t\t\t\t\tfield = {field:field,weight:1};\n\t\t\t\t}\n\t\t\t\tfields.push(field);\n\t\t\t\tweights[field.field] = ('weight' in field) ? field.weight : 1;\n\t\t\t});\n\t\t\toptions.fields = fields;\n\t\t}\n\n\n\t\treturn {\n\t\t\toptions\t\t: options as T.Options,\n\t\t\tquery\t\t: query.toLowerCase().trim(),\n\t\t\ttokens\t\t: this.tokenize(query, options.respect_word_boundaries, weights),\n\t\t\ttotal\t\t: 0,\n\t\t\titems\t\t: [],\n\t\t\tweights\t\t: weights,\n\t\t\tgetAttrFn\t: (options.nesting) ? getAttrNesting : getAttr,\n\t\t};\n\t};\n\n\t/**\n\t * Searches through all items and returns a sorted array of matches.\n\t *\n\t */\n\tsearch(query:string, options:T.UserOptions) : T.PrepareObj {\n\t\tvar self = this, score, search: T.PrepareObj;\n\n\t\tsearch  = this.prepareSearch(query, options);\n\t\toptions = search.options;\n\t\tquery   = search.query;\n\n\t\t// generate result scoring function\n\t\tconst fn_score:T.ScoreFn = options.score || self._getScoreFunction(search);\n\n\t\t// perform search and sort\n\t\tif (query.length) {\n\t\t\titerate(self.items, (item:T.ResultItem, id:string|number) => {\n\t\t\t\tscore = fn_score(item);\n\t\t\t\tif (options.filter === false || score > 0) {\n\t\t\t\t\tsearch.items.push({'score': score, 'id': id});\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\titerate(self.items, (_:T.ResultItem, id:string|number) => {\n\t\t\t\tsearch.items.push({'score': 1, 'id': id});\n\t\t\t});\n\t\t}\n\n\t\tconst fn_sort = self._getSortFunction(search);\n\t\tif (fn_sort) search.items.sort(fn_sort);\n\n\t\t// apply limits\n\t\tsearch.total = search.items.length;\n\t\tif (typeof options.limit === 'number') {\n\t\t\tsearch.items = search.items.slice(0, options.limit);\n\t\t}\n\n\t\treturn search;\n\t};\n}\n\nexport { Sifter, scoreValue, getAttr, getAttrNesting, propToArray, iterate, cmp, getPattern }\nexport * from './types.ts';\n"],"names":["arrayToPattern","chars","filter","Boolean","length","maxValueLength","join","sequencePattern","array","hasDuplicates","pattern","prev_char_count","prev_pattern","forEach","char","i","setToPattern","Array","from","Set","size","escape_regex","str","replace","reduce","longest","value","Math","max","unicodeLength","allSubstrings","input","result","start","substring","subresult","tmp","slice","charAt","push","unshift","code_points","unicode_map","multi_char_reg","latin_convert","latin_condensed","a","aa","ae","ao","au","av","ay","b","c","d","e","f","g","h","j","k","l","m","n","o","oe","oi","oo","ou","p","q","r","s","t","th","tz","u","v","vy","w","y","z","hv","latin","unicode","convert_pat","RegExp","Object","keys","normalize","form","asciifold","_asciifold","toLowerCase","generateSets","unicode_sets","addMatching","folded","to_add","folded_set","patt","match","add","code_point_min","code_point_max","composed","String","fromCharCode","code_point","generator","generateMap","multi_char","set","sort","multi_char_patt","substringsToPattern","min_replacement","map","sub_pat","mapSequence","strings","chars_replaced","sequencesToPattern","sequences","all","sequence","seq","len","substrs","inSequences","needle_seq","end","needle_parts","parts","part","needle_part","substr","Sequence","constructor","this","min","last","clone","position","last_piece","JSON","parse","stringify","last_part","pop","last_substr","clone_last_len","getPattern","undefined","match_str","overlapping","added_types","has","new_seq","old_seq","getAttr","obj","name","getAttrNesting","names","split","shift","scoreValue","token","weight","score","pos","regex","search","string","propToArray","key","isArray","iterate","object","callback","hasOwnProperty","cmp","items","settings","diacritics","tokenize","query","respect_word_boundaries","weights","tokens","words","field_regex","word","field_match","field","getScoreFunction","options","prepareSearch","_getScoreFunction","token_count","fields","field_count","getAttrFn","scoreObject","data","sum","conjunction","getSortFunction","_getSortFunction","implicit_score","sort_flds","self","sort_empty","bind","get_field","id","fld","direction","sort_fld","optsUser","assign","trim","total","nesting","fn_score","item","_","fn_sort","limit"],"mappings":"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","x_google_ignoreList":[0,1,2]}